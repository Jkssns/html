<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
// 你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:

// subtexti 是 非空 字符串
// 所有子字符串的连接等于 text ( 即subtext1 + subtext2 + ... + subtextk == text )
// 对于所有 i 的有效值( 即 1 <= i <= k ) ，subtexti == subtextk - i + 1 均成立
// 返回k可能最大值。

 

// 示例 1：

let text = "ghiabcdefhelloadamhelloabcdefghi"
// 输出：7
// 解释：我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。
// 示例 2：

// let text = "merchant"
// 输出：1
// 解释：我们可以把字符串拆分成 "(merchant)"。
// 示例 3：

// let text = "antaprezatepzapreanta"
// 输出：11
// 解释：我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)"。

// let text = "aaa"
// 输出：3

// let text = "elvtoelvto"
// 输出：2

/**
 * @param {string} text
 * @return {number}
 */
var longestDecomposition = function(text) {
    let left = 0;
    let right = text.length - 1;
	let tempStrLeft = tempStrRight = '';
    let result = 0;
    while (left < right) {
        if (text[left] === text[right]) {
			if (!tempStrLeft) {
				result += 2;
			}
        } else {
            tempStrLeft += text[left];
            tempStrRight = text[right] + tempStrRight;
			if (tempStrLeft === tempStrRight) {
				result += 2;
				tempStrLeft = tempStrRight = '';
			}
		}
        left++;
        right--;
    }

	if (left === right) {
		return result + 1;
	} else {
		return tempStrLeft.length ? result + 1 : result;
	}
};

console.log('longestDecomposition(text)::: ', longestDecomposition(text));

</script>
</html>